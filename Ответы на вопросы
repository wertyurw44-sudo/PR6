1 Что такое структура данных и зачем они нужны в программировании?
Структура данных - это способ организации, хранения и управления данными в памяти компьютера, который обеспечивает эффективный доступ к этим данным и их модификацию.
Зачем они нужны:
Эффективность: Правильный выбор структуры данных сильно влияет на скорость работы программы (время выполнения операций) и потребление памяти.
Организация: Они помогают логически группировать и связывать данные (например, словарь связывает ключ и значение).
Абстракция: Позволяют программисту думать о данных на более высоком уровне (например, "очередь" или "множество"), не вдаваясь в детали реализации.
Повторное использование: Стандартные структуры данных и алгоритмы для них — это кирпичики для построения сложных программ.

2 Какие операции поддерживают множества (sets) и для каких задач их лучше использовать?
Основные операции:
Добавление: add(element)
Удаление: remove(element) (вызывает ошибку, если элемента нет), discard(element) (не вызывает ошибку), pop() (удаляет случайный элемент)
Проверка принадлежности: element in set — работает очень быстро (O(1)).
Теоретико-множественные операции:
Объединение: union() или |
Пересечение: intersection() или &
Разность: difference() или -
Симметрическая разность: symmetric_difference() или ^
Для каких задач лучше использовать:
Удаление дубликатов из коллекции: unique_list = list(set(duplicate_list)).
Проверка на вхождение элемента (членство) — самая сильная сторона.
Сравнение коллекций: поиск общих элементов (пересечение), элементов, которые есть в одном списке, но нет в другом (разность).
Моделирование математических множеств.

3 Как создать пустой словарь и пустое множество? В чем особенность синтаксиса?
Словарь:
empty_dict = {}      
Множество:
empty_set = set()
Особенность синтаксиса: Фигурные скобки {} по умолчанию создают словарь. Поэтому для создания пустого множества нужно использовать конструктор set(). Непустое множество можно создать так: my_set = {1, 2, 3}.

4 Как создать пустой словарь и пустое множество? В чем особенность синтаксиса?
ответил ввыше

5 В чем разница между методами append() и extend() для списков? Приведите примеры.
append(element) добавляет целый объект (элемент) в конец списка. Если добавляется итерируемый объект (например, другой список), он станет одним элементом (вложенным списком).
extend(iterable) "расширяет" список, добавляя все элементы из переданного итерируемого объекта по отдельности.
my_list = [1, 2, 3]

# append()
my_list.append([4, 5])
print(my_list)  # Результат: [1, 2, 3, [4, 5]] - добавился один элемент-список

# extend()
my_list = [1, 2, 3]
my_list.extend([4, 5])
print(my_list)  # Результат: [1, 2, 3, 4, 5] - добавились два отдельных элемента


6 Как безопасно получить значение из словаря, если ключ может отсутствовать?
Метод get(key[, default]): Возвращает значение по ключу, а если ключа нет — возвращает default

7 Что такое списковые включения (list comprehensions) и в чем их преимущества?
Списковые включения (list comprehensions) - это компактный и выразительный синтаксис в Python для создания списков на основе существующих итерируемых объектов (списков, кортежей, строк, range и т.д.).
преимущества:
Лаконичность и читаемость
Более высокая производительность
Предсказуемость

8 Когда следует использовать кортежи вместо списков? Приведите 3 практических примера.
Кортежи (tuple) — неизменяемые (immutable), упорядоченные коллекции. Списки (list) — изменяемые (mutable).

Использовать кортежи, когда:

Неизменяемость как гарантия: Данные не должны (или не могут) меняться логически. Это защищает от случайных изменений и делает объект хешируемым (если все его элементы хешируемы), что позволяет использовать его как ключ словаря.

python
point = (10, 20)  # Координаты точки
graph_data = {(x, y): 'value'}  # Кортеж как ключ
Фиксированная структура данных (запись): Когда позиция элемента имеет семантическое значение (как struct в C).

python
person = ('Анна', 'Иванова', 1990)  # Имя, Фамилия, Год рождения. Порядок фиксирован.
Эффективность и безопасность: Кортежи занимают немного меньше памяти и работают немного быстрее списков. Их неизменяемость делает код более предсказуемым, особенно при передаче между функциями (не нужно бояться, что функция нечаянно изменит ваши данные).








